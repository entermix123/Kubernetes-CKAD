CONTENT

Section 7 107. Services
Section 7 108. Services - ClusterIP
Section 7 110. Practice Test - Services
Section 7 111. Ingress Networking
Section 7 112. Article: Ingress
Section 7 114. Practice Test - Ingress Networking - 1
Section 7 115. FAQ - What is the rewrite-target option?
Section 7 117. Practice Test - Ingress Networking - 2
Section 7 118. Network Policies
Section 7 119. Developing Network Policies
Section 7 121. Practice Test - Network Policies

=======================
Section 7 107. Services
=======================

Services Types
==============

1. NodePort - the service makes an internal port accessable on a port on the Node.
2. ClusterIP - the service creates a virtual IP inside the cluster to enable communication between different services such as a set of frontend servers with a set of backend servers.
3. Load Balabancer - provisions a Load Balabancer for aour application in supported cloud providers. Example of that is to distribute load across different web servers in our frontend tier.


NodePort Service
================

Mapping a port on the Node to port on the Pod.


Visual
------
				NODE
---------------------------------------------------------------------------
| NodePort [Port 30008] <---> Service [Port 80] <---> [TargetPort 80] POD |
---------------------------------------------------------------------------

Port - the port of the service (80)
Target Port - the port of the POD (80)
Service Cluster IP - the IP that the service is identified in the cluster (10.106.1.12)
Node Port - the port of the Node (30008), fixed range - 30000 - 32767


Create a service
================

service-definition.yml
--------------------------------
apiVersion: v1
kind: Service
metadata:
  name: myapp-service
spec:
    type: NodePort
    ports:			# array
     - targetPort: 80		# not mandatory, if not provided, takes 'port' as default
       port: 80			# mandatory
       nodePort: 30008		# not mandatory, if not provided, takes random free port in the fixed range: 30000 - 32767
    selector:			# specify the target PODs 
       app: myapp
       type: front-end
--------------------------------


Create service
--------------
	terminal --> kubectl create -f service-definition.yml
	# result: service "myapp-service" created


List services
-------------
	terminal --> kubectl get services

	# result:
	NAME		TYPE		CLUSTER-IP		EXTERNAL-IP	PORT(S)		AGE
	kubernetes	ClusterIP	10.96.0.1		<none>		443/TCP		16d
	myapp-service   NodePort	10.106.127.123		<none>		80:30008/TCP	5m


Access the service
------------------
	terminal --> curl https://192.168.1.2:30008

	# 192.168.1.2 - IP of the Node
	# 30008 - port to access the web server



Scenario with multiple PODs
===========================

All 3 PODs have 'labels: app: myapp' and the service have 'selector: app: myapp'.



When the service is created it looks for a matching Pod with the label and finds 3 of them. Then the service automatically selects all 3 Pods as endpoints to foreward the external requests coming from the user. The service automatically ballance the load between the 3 Pods with 'Algorithm: Random' and property 'SessionAffinity: Yes'. The service acts like a built in load ballancer to distribute load between different Pods.

					NODE
---------------------------------------------------------------------------------------
| NodePort [Port 30008] <---> Service [Port 80] <---|				      |
| IP 192.168.1.2				    |				      |
| 			-------------------------------------------------             |
|			|			|			|             |
|		[TargetPort 80] POD 1   [TargetPort 80] POD 2   [TargetPort 80] POD 3 |
|		IP 10.244.0.3		IP 10.244.0.2		IP 10.244.0.4	      |
---------------------------------------------------------------------------------------



When the Pods are distributed across different nodes
----------------------------------------------------

When we create a service without any additional configuration, Kubernetes automatically craetes our service that spans across all the Nodes in the cluster and maps the target port to the same NodePort on all the Nodes in the cluster. This way we can access our application using the IP of any Node in the cluster and using the same Port number - in this case is 30008.


					       USER
						|
		-----------------------------------------------------------------
		|				|				|
		|				|				|
IP 192.168.1.2	| Node 1	IP 192.168.1.3	| Node 2	IP 192.168.1.4	|  Node 3
-------------------------	-------------------------	-------------------------
|	NodePort 30008	|	|	NodePort 30008	|	|	NodePort 30008	|
|		  |	|	|		  |	|	|	   |		|
|		  v	|	|		  v	|	|	   v		|
|	------------------------------------------------------------------------	|
|	|				Service		selector: app: myapp	|	|
|	------------------------------------------------------------------------	|
|			|	|		|	|	|			|
|			|	|		v	|	|			|	
|	      	---------------------------------------------------------------		|
|		|	|	|		|	|	|	      |		|
|		v	|	|		v	|	|	      v		|
|	--------------	|	|	--------------	|	|	--------------	|
|	|    POD 1   |	|	|	|     POD 2  |	|	|	|     POD 3  |	|
|	| 10.244.0.3 |	|	|	| 10.244.0.2 |  |	|	| 10.244.0.4 |	|
|	|	     |	|	|	|	     |	|	|	|	     |	|
|	| labels:    |	|	|	| labels:    |	|	|	| labels:    |	|
|	|  app: myapp|	| 	|	|  app: myapp|	|	|	|  app: myapp|	|
|	--------------	|	|	--------------	|	|	--------------	|
|			|	|			|	|			|
-------------------------	-------------------------	-------------------------


We can acess the application usign the same port
	terminal --> curl http://192.168.1.2:30008
	terminal --> curl http://192.168.1.3:30008
	terminal --> curl http://192.168.1.4:30008



SUMMARIZE
---------

In any case whether there it would be a sigle Pod on a sigle Node, mutiple Pods on a single Node or multiple Pods on a mutiple Nodes, the service is created exactly the same without we having to any additional steps during the service creation. When Pods are removed or added the service is automatically updated, making it higly flexible and addaptive. One service is created we don't have to do any additional configuration changes.



===================================
Section 7 108. Services - ClusterIP
===================================

A full stack web application tipically has different Pods hosting different parts of the application. A set of Pods runnign the frontend, a set of Pods runnign the backend, aset of Pods running cache like Redis, and set of Pods running persistent DBs like MySQL.

A Kubernetes service help us group the Pods together and provide a single interface to access the Pods in the group. For example a service created for the backend Pods will help group all the backend Pods together and provide a single interface for other Pods to access the service. The requests are forwarded to one of the Pods randomly. This enables us easily and effectively to deploy microservices based application on Kubernetes cluster. Each layer can now scale or move as required without impacting communication between the various services. Each service gets and IP and name assigned to it inside of the cluster and that is the name that should be used by other Pods to access the service.


		---------------------------------------------------
		|		Forntend Service		  |		Services are used to access groups of Pods
		---------------------------------------------------
					|
	-------------------------------------------------
	|			|			|
-------------------	-----------------	-----------------
|	Pod 1	  |     |	Pod2	|	|	Pod3	|
|  IP 10.244.0.3  |	| IP 10.244.0.2	|	| IP 10.244.0.4	|		Dynamic IPs - cannot relay on them
------------------- 	-----------------	-----------------
	|			|			|
	-------------------------------------------------
				      |	
		---------------------------------------------------
		|		Backend Service			  |		Services are used to access groups of Pods
		---------------------------------------------------
					|
	-------------------------------------------------
	|			|			|
-------------------	-----------------	-----------------
|	Pod 1	  |     |	Pod2	|	|	Pod3	|
| IP 10.244.0.5	  |	| IP 10.244.0.6	|	| IP 10.244.0.7	|		Dynamic IPs - cannot relay on them
------------------- 	-----------------	-----------------
	|			|			|
	-------------------------------------------------
				     |	
		---------------------------------------------------
		|		DBs Service			  |		Services are used to access groups of Pods
		---------------------------------------------------
				      |
	-------------------------------------------------
	|			|			|
-------------------	-----------------	-----------------
|	Pod 1	  |     |	Pod2	|	|	Pod3	|
| IP 10.244.0.8	  |	| IP 10.244.0.9	|	| IP 10.244.0.10|		Dynamic IPs - cannot relay on them
------------------- 	-----------------	-----------------


This type of Service is known as ClusterIP.


ClusterIP
=========

service-definition.yml
--------------------------------
apiVersion: v1
kind: Service
metadata:
  name: back-end
spec:
    type: ClusterIP		# not mandatory, default type
    ports:
     - targetPort: 80		# expose app (backend) port
       port: 80			# expose servce port	
    selector:			 
       app: myapp		# set app name
       type: back-end		# set app type (pod label)
--------------------------------


Create service
--------------
	terminal --> kubectl create -f service-definition.yml

	# result: service "back-end" created

List services
-------------
	terminal --> kubectl get services

	# result:
	NAME		TYPE		CLUSTER-IP	EXTERNAL-IP	PORT(S)		AGE
	kubernetes	ClusterIP	10.96.0.1	<none>		443/TCP		16d
	back-end	ClusterIP	10.106.127.123	<none>		80/TCP		2m




=======================================
Section 7 110. Practice Test - Services
=======================================

1. How many Services exist on the system?
-----------------------------------------
In the current(default) namespace

List services
	terminal --> kubectl get services
	terminal --> kubectl get svc		# short syntax

	# result:
	NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
	kubernetes   ClusterIP   10.43.0.1    <none>        443/TCP   7m13s


- choose '1' as answer



2. That is a default service created by Kubernetes at launch.
-------------------------------------------------------------

- choose 'Ok' as answer




3. What is the type of the default kubernetes service?
------------------------------------------------------

List services
	terminal --> kubectl get svc		

	# result:
	NAME         TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)   AGE
	kubernetes   ClusterIP   10.43.0.1    <none>        443/TCP   7m13s	# we cansee in TYPE column

- choose 'ClusterIP' as answer




4. What is the targetPort configured on the kubernetes service?
---------------------------------------------------------------

Show service details
	terminal --> kubectl describe svc kubernetes

We can see 'targetPort:  6443/TCP'

- choose '6443' as answer


5. How many labels are configured on the kubernetes service?
------------------------------------------------------------

Show service details
	terminal --> kubectl describe svc kubernetes

We can see Labels: component=apiserver
		   provider=kubernetes

- choose '2' as answer


6. How many Endpoints are attached on the kubernetes service?
-------------------------------------------------------------

Show service details
	terminal --> kubectl describe svc kubernetes

We can see on Endpoints: 192.168.243.134:6443

- choose '1' as answer



7. How many Deployments exist on the system now?
------------------------------------------------
In the current(default) namespace

List deployments
	terminal --> kubectl get deployments

	# result:
	NAME                       READY   UP-TO-DATE   AVAILABLE   AGE
	simple-webapp-deployment   4/4     4            4           39s

- choose '1' as answer



8. What is the image used to create the pods in the deployment?
---------------------------------------------------------------

List PODs
	terminal --> kubectl get pods

	# copy one of the pods's name

Show info about pod
	terminal --> kubectl describe pod simple-webapp-deployment-646b7d6cd4-6bkfn

	# We can see Image: kodekloud/simple-webapp:red

Or describe the deployment

Show deployment details
	terminal --> k describe deploy simple-webapp-deployment

# result:
----------------------------------------
...
Pod Template:
  Labels:  name=simple-webapp
  Containers:
   simple-webapp:
    Image:         kodekloud/simple-webapp:red		# this is the used image
    Port:          8080/TCP
...
----------------------------------------

- choose 'kodekloud/simple-webapp:red' as answer




9. Are you able to accesss the Web App UI?
------------------------------------------
Try to access the Web Application UI using the tab simple-webapp-ui above the terminal.

- open the simple-webapp-ui
# error should appear

- choose 'No' as answer



10. Create a new service to access the web application using the service-definition-1.yaml file.
------------------------------------------------------------------------------------------------

Name: webapp-service
Type: NodePort
targetPort: 8080
port: 8080
nodePort: 30080
selector:
name: simple-webapp


print service-definition-1.yaml file
	terminal --> cat service-definition-1.yaml


Edit the file
	terminal --> vi service-definition-1.yaml

We can get service template definition file at https://kubernetes.io/docs/concepts/services-networking/service/

service-definition.yml
-----------------------------------
apiVersion: v1
kind: Service
metadata: 
  name: webapp-service
spec:
  type: NodePort
  ports:
  - nodePort: 30080
    port: 8080
    targetPort: 8080
  selector:
    name: simple-webapp
-----------------------------------
save changes - escape, :wq!, enter


print service-definition.yml file to ensure changes are made successfully
	terminal --> cat service-definition-1.yaml

Create service
	terminal --> kubectl create -f service-definition-1.yaml

	# result: service/webapp-service created

- click 'Check' button


11. Access the web application using the tab simple-webapp-ui above the terminal window.
----------------------------------------------------------------------------------------

open simple-webapp-ui in top right corner of the console

# we should see text 'Hello from simple-webapp-deployment-646b7d6cd4-6bkfn!'

- click 'Ok' button




=================================
Section 7 111. Ingress Networking
=================================

Recap services and ingress.

We have simple scenario - web-app for online store - www.my-online-strore.com
	- We have web-app (online store) in deployment with web-service (NodePort - accessable from outside users) on port 38080
	- We have MySQL POD with mysql-service (ClusterIP type - only internal)

Our app is accessabe on http://<node_ip>:38080. Whenever traffic increases, we increase the web-app pod replicas in the deployment to handle the additionla traffic. And the service takes care of splitting traffic between the pods.

We dont want users to type <node_id> and ports so we set an additional proxy-server to forward traffic from www.my-online-strore.com to http://<node_ip>:38080.

On Google Cloud Platform we can set our web-service to be type 'LoadBalabncer' and GCP will create automatically a proxy-server (load balancer) configured to rout traffic to the service ports on all the nodes and return information to kubernetes. The load balancer has an external IP that can be provided to users to access the application.

Next we provide new video streaming service to our clients. We want the users to access the service on www.my-online-strore.com/watch. We want the old services to be accessable on www.my-online-strore.com/wear. We deploy the streming service as separate deployment on the same cluster. We create video-service (type LoadBalancer) with port 38282. GCP also provides separate proxy-server (load balancer) for the streaming service. We must set third proxy-server (load balancer) for the separate services. Having many proxy servers (load balancers) can increase drasticly our payments on the cloud and we must be aware. We must enable ssh (secure) communication for the proxy servers in one place. That a lot of manual work and resources.

How to minimize services and payments on the cloud? What can we use to do that? - Ingress

We can set our proxy servers infrastructure in the cluster and manage it automatically with Ingress. We can look over Ingress like a layer 7 load balancer build in to the Kubernetes cluster that can be configured using native kubernetes primitives just like any other object in Kubernetes.

We still have to expose Ingress as NodePort type service or LoadBalancer for GCP, but this is just one time configuration. We are going to perform all load balancing, authentication, SSL and URL based routing configuration on the Ingress controller.


Ingress
=======

Manually configuring ingress type controller
--------------------------------------------

1. Deploy load balancing tools like nginx, haproxy or traefik - Ingress Controller 
2. Specify a set of rules to configure Ingress - Ingress Resources
	- created by definition files like other objects in kubernetes

Kubernetes cluster DO NOT come with Ingress Controller by default !


Ingress Controller
------------------

Deploy Ingress Controller
	- GSE - Google layer 7 http(s) load balabncer		# suported and maintained by the kubernetes project
	- nginx							# suported and maintained by the kubernetes project
	- Contour
	- Haproxy
	- traefik
	- Istio

In this case we will use nginx as example.

Ingress Controller has more than just nginx deployed. There is additional inteligence build in to monitor kubernetes cluster for new definitions or Ingress Resources and configure the nginx server accordingly. 

The nginx controller is deployed as just another deployment in kubernetes. This is pecial nginx image for ingress controller that has his own requirements.

nginx-ingress-controller.yaml - Deployment
------------------------------------------------------------
apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: nginx-ingress-controller
spec:
  replicas: 1
  selector: matchLabels:
    name: nginx-ingress
  template: 
    metadata:
      labels:
	name: nginx-ingress
    spec:
      containers:
	- name: nginx-ingress-controller
	  image:quay.io/kubernetes-ingress-controller/nginx-ingress-controller:0.21.0
      args:
	- /nginx-ingress-controller
	- --configmap=$(POD_NAMESPACE)/nginx-configuration
      env:
	- name: POD_NAME
	  valueFrom: 
	    fieldRef:
	      fieldPath: metadata.name
	- name: POD_NAMESPACE
	  valueFrom: 
	    fieldRef:
	      fieldPath: metadata.namespace
      ports:
	- name: http
	  containerPort: 80
	- name: https
	  containerPort: 443
------------------------------------------------------------


Nignx has a set of configuration options that must be passed
	- err-lo-path
	- keep-alive
	- ssl-protocols
	- more

In order to decaouple ths configuration data from nginx controller image, we must create a configmap object and pass them in. Below is empty configmap object that will help us manage configuration settings in the future.

ConfigMap
-----------------------------
kind: ConfigMap 
apiVersion: v1 
metadata:
  name: nginx-configuration
-----------------------------


We have to create a service type NodePort to expose the Ingress Controller to the external world.

ingress-service.yaml - Service
------------------------------------------------------------
apiVersion: v1 
kind: Service 
metadata:
  name: nginx-ingress
spec:
  type: NodePort
  ports:
  - port: 80
    targetPort: 80 protocol: TCP name: http
  - port: 443
    targetPort: 443 
    protocol: TCP name: https
  selector:
    name: nginx-ingress
------------------------------------------------------------


We need a service account with set of permissions to manage the additional inteligence for monitoring the kubernetes cluster for ingress resources and configure the nginx server when something is changed. Below is the empty service account object definition file.

service-account.yaml - Auth
------------------------------------------------------------
apiVersion: v1 kind: ServiceAccount 
metadata:
  name: nginx-ingress-serviceaccount
------------------------------------------------------------
Additional we have to configure Roles, ClusterRoler and RoleBindings


What we have mandatory for creation of simples form of Ingress Controller:
	- Deployment
	- Service
	- ConfigMap
	- Auth - Service Account
		- Roles
		- ClusterRoles
		- RoleBindings


Ingress Resources
=================

Ingress Resources are set of rules and configurations applied on the Ingress Controller.

Examples rule types
	Type 1 - forward traffic to specific application 
	Type 2 - rout traffic to specific application based on a URL (/wear, /watch)
	Type 3 - route user based on the domain name itself (wear.my-online-strore.com or watch.my-online-strore.com)


Ingress Reousrce is created with kubernetes definition file in this case:

ingress-wear.yaml
--------------------------------
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: ingress-wear
spec:
  backend:
    serviceName: wear-service
    servicePort: 80
--------------------------------

When we configure ingress we need to refer to the oficial Kubernetes documentation to take the latest changes
- https://kubernetes.io/docs/concepts/services-networking/ingress/

Create the Ingress Resource
	terminal --> kubectl create â€“f ingress-wear.yaml
	
	# result: ingress.extensions/ingress-wear created

List Ingress Resources
	terminal --> kubectl get ingress

	# result: ingress-wear * 80 2s

New Ingress is now created and rout all incoming traffic directly to the wear service.

We use rules when we want to rout traffic based on different conditions.
	- www.my-online-store.com		- Rule 1
	- www.wear.my-online-store.com		- Rule 2
	- www.watch.my-online-store.com		- Rule 3
	- Everything Else			- Rule 4

Rule 1
	- www.my-online-store.com/wear			- /wear
	- www.my-online-store.com/watch			- /watch
	- www.my-online-store.com/			- 404 not found

Rule 2
	- www.wear.my-online-store.com/return		- different backend services for returning products
	- www.wear.my-online-store.com/support		- different backend services for customer support

Rule 3
	- www.wear.my-online-store.com/movies		- path /movies
	- www.wear.my-online-store.com/tv		- path /tv

Rule 4
	- www.listen.my-online-store.com/		- 404 not foound page
	- www.eat.my-online-store.com/			- 404 not foound page
	- www.drink.my-online-store.com/		- 404 not foound page



Configure Ingress Resources in Kubernetes
-----------------------------------------

Type 1 - forward traffic to specific application:

ingress-wear-watch.yaml
--------------------------------------------------
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: ingress-wear-watch
spec:
  rules:
  - http:
      paths:
      - path: /wear
        backend:
    	  serviceName: wear-service
    	  servicePort: 80

      - path: /watch
        backend:
    	  serviceName: watch-service
    	  servicePort: 80
--------------------------------------------------

Create Ingress Resource
	terminal --> k create -f ingress-wear-watch.yaml

Show details of Ingress Resources
	terminal --> k describe ingress-wear-watch

# result:
----------------------------------------------------
Name: ingress-wear-watch
Namespace: default Address:
Address:
Default backend: default-http-backend:80 (<none>)		# if serivce is not found, redirect to the default backend address
Rules:
  Host Path Backends
  ---- ---- --------
  *
     /wear wear-service:80 (<none>)				# BE service 1
     /watch watch-service:80 (<none>) 				# BE service 2
Annotations:
Events:
  Type 		Reason 	Age 	From 			Message 
  ---- 		------ 	--- 	---- 			-------
  Normal 	CREATE 	14s 	nginx-ingress-controller Ingress default/ingress-wear-watch
----------------------------------------------------

We can configure the default backend service to show the user nice message, but not the default 404 Not Found.


Type 3 - route user based on the domain name itself (wear.my-online-strore.com or watch.my-online-strore.com):

ingress-wear-watch.yaml
--------------------------------------------------
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: ingress-wear-watch
spec:
  rules:					# we have 2 rules
  - host: wear.my-online-store.com		# we specify the incoming traffic from host 1
    http:
      paths:
      - backend:
	  serviceName: wear-service
	  servicePort: 80
  - host: watch.my-online-store.com		# we specify the incoming traffic from host 2
    http:
      paths:
      - backend:
	  serviceName: watch-service
	  servicePort: 80
--------------------------------------------------




===============================
Section 7 112. Article: Ingress
===============================

As we already discussed Ingress in our previous lecture. Here is an update.

In this article, we will see what changes have been made in previous and current versions in Ingress.

Like in apiVersion, serviceName and servicePort etc.

Now, in k8s version 1.20+ we can create an Ingress resource from the imperative way like this:-

ingress-wear-watch.yaml
--------------------------------------------------
apiVersion: networking.k8s.io/v1			# changed
kind: Ingress
metadata:
  name: ingress-wear-watch
spec:
  rules:
  - http:
      paths:
      - path: /wear
        backend:
    	  service					# changed
	    name: wear-service
    	    port:
	      number: 80

      - path: /watch
        backend:
    	  service					# changed
	    name: watch-service
    	    port:
	      number: 80
--------------------------------------------------

Format:
	terminal --> kubectl create ingress <ingress-name> --rule="host/path=service:port"

Example:
	terminal --> kubectl create ingress ingress-test --rule="wear.my-online-store.com/wear*=wear-service:80"


Find more information and examples in the below reference link:
	- https://kubernetes.io/docs/reference/generated/kubectl/kubectl-commands#-em-ingress-em-

References:
	- https://kubernetes.io/docs/concepts/services-networking/ingress
	- https://kubernetes.io/docs/concepts/services-networking/ingress/#path-types




=====================================================
Section 7 114. Practice Test - Ingress Networking - 1
=====================================================

1. We have deployed Ingress Controller, resources and applications. Explore the setup.
--------------------------------------------------------------------------------------
Note: They are in different namespaces.

List nodes
	terminal --> k get nodes

	# result:
	NAME           STATUS   ROLES           AGE     VERSION
	controlplane   Ready    control-plane   2m55s   v1.32.0


List deployments in all namespaces
	terminal --> k get deploy -A

	# result:

	NAMESPACE       NAME                       READY   UP-TO-DATE   AVAILABLE   AGE
	app-space       default-backend            1/1     1            1           2m6s
	app-space       webapp-video               1/1     1            1           2m6s
	app-space       webapp-wear                1/1     1            1           2m6s
	ingress-nginx   ingress-nginx-controller   1/1     1            1           2m5s	# we can see ingress namespace
	kube-system     coredns                    2/2     2            2           3m33s


List pods in default namespace 
	terminal --> k get pods -n kube-system

	# result: no ingress pods in default namespace

	NAME                                   READY   STATUS    RESTARTS   AGE
	coredns-77d6fd4654-dpbxm               1/1     Running   0          5m29s
	coredns-77d6fd4654-smrjm               1/1     Running   0          5m29s
	etcd-controlplane                      1/1     Running   0          5m34s
	kube-apiserver-controlplane            1/1     Running   0          5m34s
	kube-controller-manager-controlplane   1/1     Running   0          5m34s
	kube-proxy-cshnv                       1/1     Running   0          5m28s 
	kube-scheduler-controlplane            1/1     Running   0          5m34s


List pods in ingress-nginx namespace
	terminal --> k get pods -n ingress-nginx

	# result:

	NAME                                        READY   STATUS      RESTARTS   AGE
	ingress-nginx-admission-create-w5897        0/1     Completed   0          6m43s
	ingress-nginx-admission-patch-vt6rp         0/1     Completed   0          6m43s
	ingress-nginx-controller-7f45764b55-574xp   1/1     Running     0          6m44s


- click 'Ok' button




2. Which namespace is the Ingress Controller deployed in?
---------------------------------------------------------

List deployments in all namespaces
	terminal --> k get deploy -A

	# result:

	NAMESPACE       NAME                       READY   UP-TO-DATE   AVAILABLE   AGE
	app-space       default-backend            1/1     1            1           2m6s
	app-space       webapp-video               1/1     1            1           2m6s
	app-space       webapp-wear                1/1     1            1           2m6s
	ingress-nginx   ingress-nginx-controller   1/1     1            1           2m5s	# we can see ingress namespace
	kube-system     coredns                    2/2     2            2           3m33s


List pods in ingress-nginx namespace
	terminal --> k get pods -n ingress-nginx

	# result:

	NAME                                        READY   STATUS      RESTARTS   AGE
	ingress-nginx-admission-create-w5897        0/1     Completed   0          6m43s
	ingress-nginx-admission-patch-vt6rp         0/1     Completed   0          6m43s
	ingress-nginx-controller-7f45764b55-574xp   1/1     Running     0          6m44s


- choose 'ingress-nginx' as answer




3. What is the name of the Ingress Controller Deployment?
---------------------------------------------------------

List deployments in ingress-nginx namespace
	terminal --> k get deploy -n ingress-nginx

	# result:

	NAME                       READY   UP-TO-DATE   AVAILABLE   AGE
	ingress-nginx-controller   1/1     1            1           10m

- choose 'ingress-nginx-controller' as answer




4. Which namespace are the applications deployed in?
----------------------------------------------------

List deployments in all namespaces
	terminal --> k get deploy -A

	# result: we can see in app-space namespace 2 webapp pods and 1 backend pod

	NAMESPACE       NAME                       READY   UP-TO-DATE   AVAILABLE   AGE
	app-space       default-backend            1/1     1            1           2m6s
	app-space       webapp-video               1/1     1            1           2m6s
	app-space       webapp-wear                1/1     1            1           2m6s
	ingress-nginx   ingress-nginx-controller   1/1     1            1           2m5s	
	kube-system     coredns                    2/2     2            2           3m33s


- choose 'app-space' as asnwer




5. How many applications are deployed in the app-space namespace?
-----------------------------------------------------------------
Count the number of deployments in this namespace.


List deployments in all namespaces
	terminal --> k get deploy -A

# result: # we can see in app-space namespace 2 webapp pods and 1 backend pod

NAMESPACE       NAME                       READY   UP-TO-DATE   AVAILABLE   AGE
app-space       default-backend            1/1     1            1           2m6s	# 1
app-space       webapp-video               1/1     1            1           2m6s	# 2
app-space       webapp-wear                1/1     1            1           2m6s	# 3
ingress-nginx   ingress-nginx-controller   1/1     1            1           2m5s	
kube-system     coredns                    2/2     2            2           3m33s


- choose '3' as asnwer




6. Which namespace is the Ingress Resource deployed in?
-------------------------------------------------------

List Ingress Controller Resources in all namespaces
	terminal --> k get ingress -A

# result:

NAMESPACE   NAME                 CLASS    HOSTS   ADDRESS          PORTS   AGE
app-space   ingress-wear-watch   <none>   *       172.20.187.214   80      15m


- choose 'app-space' as answer




7. What is the name of the Ingress Resource?
--------------------------------------------

List Ingress Resources in all namespaces
	terminal --> k get ingress -A

# result:

NAMESPACE   NAME                 CLASS    HOSTS   ADDRESS          PORTS   AGE
app-space   ingress-wear-watch   <none>   *       172.20.187.214   80      15m


- choose 'ingress-wear-watch' as answer




8. What is the Host configured on the Ingress Resource?
-------------------------------------------------------
The host entry defines the domain name that users use to reach the application like www.google.com


Show Ingress Resource details
	terminal --> k describe ingress ingress-wear-watch -n app-space

	# k 						- common kubernetes command
	# describe					- show details for object
	# ingress					- target object type
	# ingress-wear-watch				- target object name
	# -n app-space					- namespace of the object

# result:
-----------------------------------------------------------------
Name:             ingress-wear-watch
Labels:           <none>
Namespace:        app-space
Address:          172.20.187.214
Ingress Class:    <none>
Default backend:  <default>
Rules:
  Host        Path  Backends
  ----        ----  --------
  *           							# '*' mean 'all'
              /wear    wear-service:8080 (172.17.0.4:8080)
              /watch   video-service:8080 (172.17.0.5:8080)
Annotations:  nginx.ingress.kubernetes.io/rewrite-target: /
              nginx.ingress.kubernetes.io/ssl-redirect: false
Events:
  Type    Reason  Age                From                      Message
  ----    ------  ----               ----                      -------
  Normal  Sync    17m (x2 over 17m)  nginx-ingress-controller  Scheduled for sync
-----------------------------------------------------------------


- choose 'All Hosts (*)' as answer




9. What backend is the /wear path on the Ingress configured with?
-----------------------------------------------------------------

Show Ingress Resource details
	terminal --> k describe ingress ingress-wear-watch -n app-space

	# k 						- common kubernetes command
	# describe					- show details for object
	# ingress					- target object type
	# ingress-wear-watch				- target object name
	# -n app-space					- namespace of the object

# result:
-----------------------------------------------------------------
Name:             ingress-wear-watch
Labels:           <none>
Namespace:        app-space
Address:          172.20.187.214
Ingress Class:    <none>
Default backend:  <default>
Rules:
  Host        Path  Backends
  ----        ----  --------
  *           							
              /wear    wear-service:8080 (172.17.0.4:8080)	# This si the answer
              /watch   video-service:8080 (172.17.0.5:8080)
Annotations:  nginx.ingress.kubernetes.io/rewrite-target: /
              nginx.ingress.kubernetes.io/ssl-redirect: false
Events:
  Type    Reason  Age                From                      Message
  ----    ------  ----               ----                      -------
  Normal  Sync    17m (x2 over 17m)  nginx-ingress-controller  Scheduled for sync
-----------------------------------------------------------------


- choose 'wear-service' as answer




10. At what path is the video streaming application made available on the Ingress?
----------------------------------------------------------------------------------

Show Ingress Resource details
	terminal --> k describe ingress ingress-wear-watch -n app-space

	# k 						- common kubernetes command
	# describe					- show details for object
	# ingress					- target object type
	# ingress-wear-watch				- target object name
	# -n app-space					- namespace of the object

# result:
-----------------------------------------------------------------
Name:             ingress-wear-watch
Labels:           <none>
Namespace:        app-space
Address:          172.20.187.214
Ingress Class:    <none>
Default backend:  <default>
Rules:
  Host        Path  Backends
  ----        ----  --------
  *           							
              /wear    wear-service:8080 (172.17.0.4:8080)	
              /watch   video-service:8080 (172.17.0.5:8080)	# This si the answer
Annotations:  nginx.ingress.kubernetes.io/rewrite-target: /
              nginx.ingress.kubernetes.io/ssl-redirect: false
Events:
  Type    Reason  Age                From                      Message
  ----    ------  ----               ----                      -------
  Normal  Sync    17m (x2 over 17m)  nginx-ingress-controller  Scheduled for sync
-----------------------------------------------------------------


- choose '/watch' as answer



11. If the requirement does not match any of the configured paths in the Ingress, to which service are the requests forwarded?
------------------------------------------------------------------------------------------------------------------------------

Show Ingress Resource details
	terminal --> k describe ingress ingress-wear-watch -n app-space

	# k 						- common kubernetes command
	# describe					- show details for object
	# ingress					- target object type
	# ingress-wear-watch				- target object name
	# -n app-space					- namespace of the object

# result:
-----------------------------------------------------------------
Name:             ingress-wear-watch
Labels:           <none>
Namespace:        app-space
Address:          172.20.187.214
Ingress Class:    <none>
Default backend:  <default>		# This si the answer					
Rules:
  Host        Path  Backends
  ----        ----  --------
  *           							
              /wear    wear-service:8080 (172.17.0.4:8080)	
              /watch   video-service:8080 (172.17.0.5:8080)	
Annotations:  nginx.ingress.kubernetes.io/rewrite-target: /
              nginx.ingress.kubernetes.io/ssl-redirect: false
Events:
  Type    Reason  Age                From                      Message
  ----    ------  ----               ----                      -------
  Normal  Sync    17m (x2 over 17m)  nginx-ingress-controller  Scheduled for sync
-----------------------------------------------------------------


- choose 'default-backend-service' as answer




12. Now view the Ingress Service using the tab at the top of the terminal. Which page do you see?
-------------------------------------------------------------------------------------------------
Click on the tab named Ingress.

Click on the Ingress tab above top right corner of the console

- choose '404 Error page' as answer



13. View the applications by appending /wear and /watch to the URL you opened in the previous step.
---------------------------------------------------------------------------------------------------

Open the Ingress tab and set '/wear' and then '/watch' to the browser link

Open  https://30080-port-cqnnpgyoy3sex3f7.labs.kodekloud.com/wear
Open  https://30080-port-cqnnpgyoy3sex3f7.labs.kodekloud.com/watch

# both pages works

- click 'Ok' as answer




14. You are requested to change the URLs at which the applications are made available.
--------------------------------------------------------------------------------------
Make the video application available at /stream.


Ingress: ingress-wear-watch
Path: /stream
Backend Service: video-service
Backend Service Port: 8080


Edit Ingress Resource
	terminal --> k edit ingress ingress-wear-watch -n app-space

	# k 						- common kubernetes command
	# edit						- edit details for object
	# ingress					- target object type
	# ingress-wear-watch				- target object name
	# -n app-space					- namespace of the object


# result:
-----------------------------------------------------------
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/ssl-redirect: "false"
  creationTimestamp: "2025-01-30T17:30:54Z"
  generation: 1
  name: ingress-wear-watch
  namespace: app-space
  resourceVersion: "798"
  uid: f7e50de5-1560-4cb9-a46f-42e51a0d1dea
spec:
  rules:
  - http:
      paths:
      - backend:
          service:
            name: wear-service
            port:
              number: 8080
        path: /wear				
        pathType: Prefix
      - backend:
          service:
            name: video-service
            port:
              number: 8080
        path: /stream			# modified to /stream
        pathType: Prefix
status:
  loadBalancer:
    ingress:
    - ip: 172.20.123.160
-----------------------------------------------------------
save changes - escape, :wq!, enter

# result: ingress.networking.k8s.io/ingress-wear-watch edited

Verify changes
	terminal --> k describe ingress ingress-wear-watch -n app-space

	OR

	Open https://30080-port-cqnnpgyoy3sex3f7.labs.kodekloud.com/weatch - 404 page must appear
	Open https://30080-port-cqnnpgyoy3sex3f7.labs.kodekloud.com/stream - working page

- click 'Check' button



15. View the Video application using the /stream URL in your browser.
---------------------------------------------------------------------
Click on the Ingress tab above your terminal, if its not open already, and append /stream to the URL in the browser.

Open https://30080-port-cqnnpgyoy3sex3f7.labs.kodekloud.com/stream - working page

- click 'Ok' button




16. A user is trying to view the /eat URL on the Ingress Service. Which page would he see?
------------------------------------------------------------------------------------------
If not open already, click on the Ingress tab above your terminal, and append /eat to the URL in the browser.


Open https://30080-port-cqnnpgyoy3sex3f7.labs.kodekloud.com/eat - 404 page

- choose '404 Error page' as answer




17. Due to increased demand, your business decides to take on a new venture. You acquired a food delivery company. Their applications have been migrated over to your cluster.
----------------------------------------------------------------------------------------
Inspect the new deployments in the app-space namespace.

List pods in app-space namespace
	terminal --> k get pods -n app-space

# result:

NAME                               READY   STATUS    RESTARTS   AGE
default-backend-5cd488d85c-zhcbn   1/1     Running   0          12m
webapp-food-57d799b775-9hblf       1/1     Running   0          48s	# this is the new app for food
webapp-video-cb475db9c-r4czr       1/1     Running   0          12m
webapp-wear-6886df6554-vxmg6       1/1     Running   0          12m


- click 'Ok' button




18. You are requested to add a new path to your ingress to make the food delivery application available to your customers.
--------------------------------------------------------------------------------------------------------------------------
Make the new application available at /eat.

Ingress: ingress-wear-watch
Path: /eat
Backend Service: food-service
Backend Service Port: 8080

Edit Ingress Resource
	terminal --> k edit ingress ingress-wear-watch -n app-space

	# k 						- common kubernetes command
	# edit						- edit details for object
	# ingress					- target object type
	# ingress-wear-watch				- target object name
	# -n app-space					- namespace of the object


# result:
-----------------------------------------------------------
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
    nginx.ingress.kubernetes.io/ssl-redirect: "false"
  creationTimestamp: "2025-01-30T17:30:54Z"
  generation: 1
  name: ingress-wear-watch
  namespace: app-space
  resourceVersion: "798"
  uid: f7e50de5-1560-4cb9-a46f-42e51a0d1dea
spec:
  rules:
  - http:
      paths:
      - backend:
          service:
            name: wear-service
            port:
              number: 8080
        path: /wear				
        pathType: Prefix
      - backend:
          service:
            name: video-service
            port:
              number: 8080
        path: /stream			
        pathType: Prefix
      - backend:			# added from here
          service:
            name: food-service
            port:
              number: 8080
        path: /eat			
        pathType: Prefix		# to here
status:
  loadBalancer:
    ingress:
    - ip: 172.20.123.160
-----------------------------------------------------------
save changes - escape, :wq!, enter

# result: ingress.networking.k8s.io/ingress-wear-watch edited

Verify changes
	terminal --> k describe ingress ingress-wear-watch -n app-space

	OR

	Open https://30080-port-cqnnpgyoy3sex3f7.labs.kodekloud.com/eat - working page

- click 'Check' button



19. View the Food delivery application using the /eat URL in your browser.
--------------------------------------------------------------------------
Click on the Ingress tab above your terminal, if its not open already, and append /eat to the URL in the browser.

Open https://30080-port-cqnnpgyoy3sex3f7.labs.kodekloud.com/eat - working page





20. A new payment service has been introduced. Since it is critical, the new application is deployed in its own namespace.
--------------------------------------------------------------------------------------------------------------------------
Identify the namespace in which the new application is deployed.

List pods in all namespaces
	terminal --> k get pods -A

# result:

NAMESPACE        NAME                                        READY   STATUS      RESTARTS   AGE
app-space        default-backend-5cd488d85c-zhcbn            1/1     Running     0          19m
app-space        webapp-food-57d799b775-9hblf                1/1     Running     0          7m46s
app-space        webapp-video-cb475db9c-r4czr                1/1     Running     0          19m
app-space        webapp-wear-6886df6554-vxmg6                1/1     Running     0          19m
critical-space   webapp-pay-6888bbb889-ff5jk                 1/1     Running     0          90s	  # this is the payment app
ingress-nginx    ingress-nginx-admission-create-v65v5        0/1     Completed   0          19m
ingress-nginx    ingress-nginx-admission-patch-n27cr         0/1     Completed   0          19m
ingress-nginx    ingress-nginx-controller-7f45764b55-6vkvt   1/1     Running     0          19m
kube-flannel     kube-flannel-ds-rw5vg                       1/1     Running     0          21m
kube-system      coredns-77d6fd4654-26f27                    1/1     Running     0          21m
kube-system      coredns-77d6fd4654-jw6ws                    1/1     Running     0          21m
kube-system      etcd-controlplane                           1/1     Running     0          21m
kube-system      kube-apiserver-controlplane                 1/1     Running     0          21m
kube-system      kube-controller-manager-controlplane        1/1     Running     0          21m
kube-system      kube-proxy-rd5b9                            1/1     Running     0          21m
kube-system      kube-scheduler-controlplane                 1/1     Running     0          21m


- choose 'critical-space' as answer



21. What is the name of the deployment of the new application?
--------------------------------------------------------------

List deployments in the 'critical-space' namespace
	terminal --> k get deploy -n critical-space

# result:

NAME         READY   UP-TO-DATE   AVAILABLE   AGE
webapp-pay   1/1     1            1           4m50s

- choose 'webapp-pay' as answer



22. You are requested to make the new application available at /pay.
--------------------------------------------------------------------
Identify and implement the best approach to making this application available on the ingress controller and test to make sure its working. Look into annotations: rewrite-target as well.

Ingress Created
Path: /pay
Configure correct backend service
Configure correct backend port

Best practice is to create Ingress Resource fot this app in his namespace

Show service in the 'critical-space' namespace - find webapp-pay pod service
	terminal --> k get svc -n critical-space

# result:

NAME          TYPE        CLUSTER-IP     EXTERNAL-IP   PORT(S)    AGE
pay-service   ClusterIP   172.20.79.21   <none>        8282/TCP   9m30s

# we will use the service name - pay-service
# we will use the service port - 8282


Show help commands for creating a Ingress
	terminal --> k create ingress -h

We will use the first example:
  # Create a single ingress called 'simple' that directs requests to foo.com/bar to svc
  # svc1:8080 with a TLS secret "my-cert"
  kubectl create ingress simple --rule="foo.com/bar=svc1:8080,tls=my-cert"

Create Ingress definition file
	terminal --> kubectl create ingress ingress-pay -n critical-space --rule="/pay=pay-service:8282"

	# kubectl					- common kubernetes command
	# create					- create object
	# ingress					- object type
	# ingress-pay					- object name
	# -n app-space					- namespace of the object
	# --rule="/pay=pay-service:8282"		- specify the path (/pay),service (pay-service) and the port (:8282)

	# result: ingress.networking.k8s.io/ingress-pay created


Verify Ingress creation
	terminal --> k get ingress -n critical-space

# result:

NAME          CLASS    HOSTS   ADDRESS   PORTS   AGE
ingress-pay   <none>   *                 80      26s


Print the created Ingress
	terminal --> k describe ingress ingress-pay -n critical-space

# result:
-----------------------------------------------------------
Name:             ingress-pay
Labels:           <none>
Namespace:        critical-space
Address:          172.20.123.160
Ingress Class:    <none>
Default backend:  <default>
Rules:
  Host        Path  Backends
  ----        ----  --------
  *           
              /pay   pay-service:8282 (172.17.0.11:8080)
Annotations:  <none>
Events:
  Type    Reason  Age                 From                      Message
  ----    ------  ----                ----                      -------
  Normal  Sync    71s (x2 over 103s)  nginx-ingress-controller  Scheduled for sync
-----------------------------------------------------------

Check if the service is working
	Open https://30080-port-cqnnpgyoy3sex3f7.labs.kodekloud.com/pay - 404 Error page

Check the work of the pod
	terminal --> k get pods -n critical-space

# result:

NAME                          READY   STATUS    RESTARTS   AGE
webapp-pay-6888bbb889-ff5jk   1/1     Running   0          19m

Show logs of the pod	
	terminal --> k logs webapp-pay-6888bbb889-ff5jk -n critical-space

# result:

 * Serving Flask app 'app' (lazy loading)
 * Environment: production
   WARNING: This is a development server. Do not use it in a production deployment.
   Use a production WSGI server instead.
 * Debug mode: off
 * Running on all addresses.
   WARNING: This is a development server. Do not use it in a production deployment.
 * Running on http://172.17.0.11:8080/ (Press CTRL+C to quit)
172.17.0.9 - - [30/Jan/2025 18:07:33] "GET /pay HTTP/1.1" 404 -


We need to set Annotation beacuse the app do not have /pay path.

In Section 9 241. Ingress - Annotations and rewrite-target, we can see how to do it

Edit the Ingress Resource and set Annotations
	terminal --> k edit ingress ingress-pay -n critical-space

	# k 						- common kubernetes command
	# edit						- edit details for object
	# ingress					- target object type
	# ingress-wear-watch				- target object name
	# -n app-space					- namespace of the object


# result:
-----------------------------------------------------------
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  creationTimestamp: "2025-01-30T18:04:39Z"
  generation: 1
  name: ingress-pay
  namespace: critical-space
  resourceVersion: "3802"
  uid: ea3a999d-492e-4ced-8b14-823206c64661
  annotations:						# added
    nginx.ingress.kubernetes.io/rewrite-target: /	# added
spec:
  rules:
  - http:
      paths:
      - backend:
          service:
            name: pay-service
            port:
              number: 8282
        path: /pay
        pathType: Exact
status:
  loadBalancer:
    ingress:
    - ip: 172.20.123.160
-----------------------------------------------------------
save changes - escape, :wq!, enter

# result: ingress.networking.k8s.io/ingress-pay edited

Open https://30080-port-cqnnpgyoy3sex3f7.labs.kodekloud.com/pay - Working page

- click 'Check' button




23. View the Payment application using the /pay URL in your browser.
--------------------------------------------------------------------
Click on the Ingress tab above your terminal, if its not open already, and append /pay to the URL in the browser.

Open https://30080-port-cqnnpgyoy3sex3f7.labs.kodekloud.com/pay - Working page

- click 'Ok' button





=======================================================
Section 7 115. FAQ - What is the rewrite-target option?
=======================================================

Different ingress controllers have different options that can be used to customise the way it works. NGINX Ingress controller has many options that can be seen here (https://kubernetes.github.io/ingress-nginx/examples/). I would like to explain one such option that we will use in our labs. The Rewrite (https://kubernetes.github.io/ingress-nginx/examples/rewrite/) target option.

Our watch app displays the video streaming webpage at http://<watch-service>:<port>/

Our wear app displays the apparel webpage at http://<wear-service>:<port>/


We must configure Ingress to achieve the below. When user visits the URL on the left, his request should be forwarded internally to the URL on the right. Note that the /watch and /wear URL path are what we configure on the ingress controller so we can forwarded users to the appropriate application in the backend. The applications don't have this URL/Path configured on them:

http://<ingress-service>:<ingress-port>/watch --> http://<watch-service>:<port>/
http://<ingress-service>:<ingress-port>/wear --> http://<wear-service>:<port>/


Without the rewrite-target option, this is what would happen:

http://<ingress-service>:<ingress-port>/watch --> http://<watch-service>:<port>/watch
http://<ingress-service>:<ingress-port>/wear --> http://<wear-service>:<port>/wear


Notice watch and wear at the end of the target URLs. The target applications are not configured with /watch or /wear paths. They are different applications built specifically for their purpose, so they don't expect /watch or /wear in the URLs. And as such the requests would fail and throw a 404 not found error.


To fix that we want to "ReWrite" the URL when the request is passed on to the watch or wear applications. We don't want to pass in the same path that user typed in. So we specify the rewrite-target option. This rewrites the URL by replacing whatever is under rules->http->paths->path which happens to be /pay in this case with the value in rewrite-target. This works just like a search and replace function.

For example: replace(path, rewrite-target)
In our case: replace("/path","/")

--------------------------------------------------
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  name: test-ingress
  namespace: critical-space
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /
spec:
  rules:
  - http:
      paths:
      - path: /pay
        backend:
          serviceName: pay-service
          servicePort: 8282
--------------------------------------------------



In another example given here (https://kubernetes.github.io/ingress-nginx/examples/rewrite/), this could also be:

replace("/something(/|$)(.*)", "/$2")


--------------------------------------------------
apiVersion: extensions/v1beta1
kind: Ingress
metadata:
  annotations:
    nginx.ingress.kubernetes.io/rewrite-target: /$2
  name: rewrite
  namespace: default
spec:
  rules:
  - host: rewrite.bar.com
    http:
      paths:
      - backend:
          serviceName: http-svc
          servicePort: 80
        path: /something(/|$)(.*)
--------------------------------------------------



=====================================================
Section 7 117. Practice Test - Ingress Networking - 2
=====================================================

In this practice Test we will deploy Ingress Controller.

Set alias
	terminal --> alias k=kubectl


1. We have deployed two applications. Explore the setup.
--------------------------------------------------------
Note: They are in a different namespace.


List all pods
	terminal --> k get pods -A

# result:

NAMESPACE      NAME                                   READY   STATUS    RESTARTS   AGE
app-space      default-backend-5cd488d85c-8lmgl       1/1     Running   0          41s
app-space      webapp-video-cb475db9c-jgn9m           1/1     Running   0          41s
app-space      webapp-wear-6886df6554-hdl2g           1/1     Running   0          41s
kube-flannel   kube-flannel-ds-gxd66                  1/1     Running   0          2m38s
kube-system    coredns-77d6fd4654-f42zx               1/1     Running   0          2m38s
kube-system    coredns-77d6fd4654-hntkp               1/1     Running   0          2m38s
kube-system    etcd-controlplane                      1/1     Running   0          2m42s
kube-system    kube-apiserver-controlplane            1/1     Running   0          2m42s
kube-system    kube-controller-manager-controlplane   1/1     Running   0          2m42s
kube-system    kube-proxy-rrrch                       1/1     Running   0          2m38s
kube-system    kube-scheduler-controlplane            1/1     Running   0          2m42s


- click 'Ok' button




2. Let us now deploy an Ingress Controller. First, create a namespace called ingress-nginx.
-------------------------------------------------------------------------------------------
We will isolate all ingress related objects into its own namespace.

Name: ingress-nginx

Show namespace create help commands 
	terminal --> k create namespace -h

# we will use the example
  # Create a new namespace named my-namespace
  kubectl create namespace my-namespace

Create namespace ingress-nginx
	terminal --> k create namespace ingress-nginx

	# result: namespace/ingress-nginx created


Check if the namespace is created
	terminal --> k get ns			# ns - short syntax for namespace

# result:

NAME              STATUS   AGE
app-space         Active   4m59s
default           Active   7m4s
ingress-nginx     Active   22s			# created
kube-flannel      Active   6m59s
kube-node-lease   Active   7m4s
kube-public       Active   7m4s
kube-system       Active   7m4s


- click 'Check' button



2. The NGINX Ingress Controller requires a ConfigMap object. Create a ConfigMap object with name ingress-nginx-controller in the ingress-nginx namespace.
----------------------------------------------------------------------------------------------------
No data needs to be configured in the ConfigMap.

Name: ingress-nginx-controller

Show create configmap help commands
	terminal --> k create configmap -h

Create ingress-nginx-controller configmap in the ingress-nginx namespace
	terminal --> k create configmap ingress-nginx-controller -n ingress-nginx
	
	# result: configmap/ingress-nginx-controller created

- click 'Check' button



3. The NGINX Ingress Controller requires two ServiceAccounts. Create both ServiceAccount with name ingress-nginx and ingress-nginx-admission in the ingress-nginx namespace.
-------------------------------------------------------------------------------------------------------
Use the spec provided below.

Name: ingress-nginx
Name: ingress-nginx-admission

Show create service-account help commands
	terminal --> k create sa -h

# we will use the example
  # Create a new service account named my-service-account
  kubectl create serviceaccount my-service-account

Create the service accounts
	terminal --> k create sa ingress-nginx -n ingress-nginx
	terminal --> k create sa ingress-nginx-admission -n ingress-nginx

	# result: serviceaccount/ingress-nginx created
	# result: serviceaccount/ingress-nginx-admission created

Verify service accounts creation
	terminal --> k get sa -n ingress-nginx

# result:

NAME                      SECRETS   AGE
default                   0         10m
ingress-nginx             0         107s
ingress-nginx-admission   0         99s

- click 'Check' button




5. We have created the Roles, RoleBindings, ClusterRoles, and ClusterRoleBindings for the ServiceAccount. Check it out!!
------------------------------------------------------------------------------------------------------------------------

List roles in ingress-nginx namespace
	terminal --> k get roles -n ingress-nginx

# result:

NAME                      CREATED AT
ingress-nginx             2025-01-30T18:54:08Z
ingress-nginx-admission   2025-01-30T18:54:09Z

Show details for ingress-nginx role
	terminal --> k describe role ingress-nginx -n ingress-nginx

# result:
-----------------------------------------------------------------
Name:         ingress-nginx
Labels:       app.kubernetes.io/component=controller
              app.kubernetes.io/instance=ingress-nginx
              app.kubernetes.io/managed-by=Helm
              app.kubernetes.io/name=ingress-nginx
              app.kubernetes.io/part-of=ingress-nginx
              app.kubernetes.io/version=1.1.2
              helm.sh/chart=ingress-nginx-4.0.18
Annotations:  <none>
PolicyRule:
  Resources                           Non-Resource URLs  Resource Names               Verbs
  ---------                           -----------------  --------------               -----
  events                              []                 []                           [create patch]
  configmaps                          []                 []                           [get list watch create]
  endpoints                           []                 []                           [get list watch]
  pods                                []                 []                           [get list watch]
  secrets                             []                 []                           [get list watch]
  services                            []                 []                           [get list watch]
  ingressclasses.networking.k8s.io    []                 []                           [get list watch]
  ingresses.networking.k8s.io         []                 []                           [get list watch]
  configmaps                          []                 [ingress-controller-leader]  [get update]
  namespaces                          []                 []                           [get]
  ingresses.networking.k8s.io/status  []                 []                           [update]
-----------------------------------------------------------------



List RoleBindings in ingress-nginx namespace
	terminal --> k get rolebindings -n ingress-nginx

# result:

NAME                      ROLE                           AGE
ingress-nginx             Role/ingress-nginx             117s
ingress-nginx-admission   Role/ingress-nginx-admission   117s


List ClusterRoles in ingress-nginx namespace
	terminal --> k get clusterroles -n ingress-nginx

List ClusterRoleBindings in ingress-nginx namespace
	terminal --> k get clusterrolebindings -n ingress-nginx


- click 'Ok' button




6. Let us now deploy the Ingress Controller. Create the Kubernetes objects using the given file.
------------------------------------------------------------------------------------------------
The Deployment and it's service configuration is given at /root/ingress-controller.yaml. There are several issues with it. Try to fix them.

Note: Do not edit the default image provided in the given file. The image validation check passes when other issues are resolved.


Deployed in the correct namespace.
Replicas: 1
Use the right image
Namespace: ingress-nginx
Service name: ingress-nginx-controller
NodePort: 30080


Show files 
	terminal --> ls			# result: ingress-controller.yaml

Print ingress-controller.yaml file
	terminal --> cat ingress-controller.yaml


#  result:

ingress-controller.yaml
-------------------------------------------------------------
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app.kubernetes.io/component: controller
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.1.2
    helm.sh/chart: ingress-nginx-4.0.18
  name: ingress-nginx-controller
  namespace: ingress-
spec:
  minReadySeconds: 0
  revisionHistoryLimit: 10
  selector:
    matchLabels:
      app.kubernetes.io/component: controller
      app.kubernetes.io/instance: ingress-nginx
      app.kubernetes.io/name: ingress-nginx
  template:
    metadata:
      labels:
        app.kubernetes.io/component: controller
        app.kubernetes.io/instance: ingress-nginx
        app.kubernetes.io/name: ingress-nginx
    spec:
      containers:
      - args:
        - /nginx-ingress-controller
        - --publish-service=$(POD_NAMESPACE)/ingress-nginx-controller
        - --election-id=ingress-controller-leader
        - --watch-ingress-without-class=true
        - --default-backend-service=app-space/default-http-backend
        - --controller-class=k8s.io/ingress-nginx
        - --ingress-class=nginx
        - --configmap=$(POD_NAMESPACE)/ingress-nginx-controller
        - --validating-webhook=:8443
        - --validating-webhook-certificate=/usr/local/certificates/cert
        - --validating-webhook-key=/usr/local/certificates/key
        env:
        - name: POD_NAME
          valueFrom:
            fieldRef:
              fieldPath: metadata.name
        - name: POD_NAMESPACE
          valueFrom:
            fieldRef:
              fieldPath: metadata.namespace
        - name: LD_PRELOAD
          value: /usr/local/lib/libmimalloc.so
        image: registry.k8s.io/ingress-nginx/controller:v1.1.2@sha256:28b11ce69e57843de44e3db6413e98d09de0f6688e33d4bd384002a44f78405c
        imagePullPolicy: IfNotPresent
        lifecycle:
          preStop:
            exec:
              command:
              - /wait-shutdown
        livenessProbe:
          failureThreshold: 5
          httpGet:
            path: /healthz
            port: 10254
            scheme: HTTP
          initialDelaySeconds: 10
          periodSeconds: 10
          successThreshold: 1
          timeoutSeconds: 1
        name: controller
        ports:
        - name: http
            containerPort: 80
          protocol: TCP
        - containerPort: 443
          name: https
          protocol: TCP
        - containerPort: 8443
          name: webhook
          protocol: TCP
        readinessProbe:
          failureThreshold: 3
          httpGet:
            path: /healthz
            port: 10254
            scheme: HTTP
          initialDelaySeconds: 10
          periodSeconds: 10
          successThreshold: 1
          timeoutSeconds: 1
        resources:
          requests:
            cpu: 100m
            memory: 90Mi
        securityContext:
          allowPrivilegeEscalation: true
          capabilities:
            add:
            - NET_BIND_SERVICE
            drop:
            - ALL
          runAsUser: 101
        volumeMounts:
        - mountPath: /usr/local/certificates/
          name: webhook-cert
          readOnly: true
      dnsPolicy: ClusterFirst
      nodeSelector:
        kubernetes.io/os: linux
      serviceAccountName: ingress-nginx
      terminationGracePeriodSeconds: 300
      volumes:
      - name: webhook-cert
        secret:
          secretName: ingress-nginx-admission

---
apiVersion: v1
kind: Service
metadata:
  creationTimestamp: null
  labels:
    app.kubernetes.io/component: controller
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.1.2
    helm.sh/chart: ingress-nginx-4.0.18
  name: ingress-controller
  namespace: ingress-nginx
spec:
  ports:
  - port: 80
    protocol: TCP
    targetPort: 80
    nodeport: 30080
  selector:
    app.kubernetes.io/component: controller
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
  type: NodePort
-------------------------------------------------------------


Try to create the controller
	terminal --> k create -f ingress-controller.yaml

# result: error: error parsing ingress-controller.yaml: error converting YAML to JSON: yaml: line 73: mapping values are not allowed in this context



Edit the file ad fix the issues
	terminal --> vi ingress-controller.yaml

-------------------------------------------------------------
...
  namespace: ingress-nginx				# fixed namespace
...
        ports:
        - name: http
          containerPort: 80			# fixed identation
          protocol: TCP
        - containerPort: 443
...

apiVersion: v1
kind: Service
metadata:
  creationTimestamp: null
  labels:
    app.kubernetes.io/component: controller
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/name: ingress-nginx
    app.kubernetes.io/part-of: ingress-nginx
    app.kubernetes.io/version: 1.1.2
    helm.sh/chart: ingress-nginx-4.0.18
  name: ingress-nginx-controller			# fixed service name
  namespace: ingress-nginx
spec:
  ports:
  - port: 80
    protocol: TCP
    targetPort: 80
    nodePort: 30080					# fixed typo from 'nodeport' to 'nodePort'
  selector:
    app.kubernetes.io/component: controller
    app.kubernetes.io/instance: ingress-nginx
    app.kubernetes.io/name: ingress-nginx
  type: NodePort
...
-------------------------------------------------------------
save changes - escape, :wq!, enter

Create the controller
	terminal --> k create -f ingress-controller.yaml

	# result:
	deployment.apps/ingress-nginx-controller created
	service/ingress-nginx-controller created

If additional error appears - fix it
	terminal --> vi ingress-controller.yaml

Apply changes
	terminal --> k aplly -f ingress-controller.yaml

- click 'Check' button




7. Create the ingress resource to make the applications available at /wear and /watch on the Ingress service.
-------------------------------------------------------------------------------------------------------------
Also, make use of rewrite-target annotation field: - nginx.ingress.kubernetes.io/rewrite-target: /

Ingress resource comes under the namespace scoped, so don't forget to create the ingress in the app-space namespace.


Ingress Created
Path: /wear
Path: /watch
Configure correct backend service for /wear
Configure correct backend service for /watch
Configure correct backend port for /wear service
Configure correct backend port for /watch service


Show all pods
	terminal --> k get pods -A

	# result:

	NAMESPACE       NAME                                        READY   STATUS      RESTARTS        AGE
	app-space       default-backend-5cd488d85c-lbgbv            1/1     Running     0               14m
	app-space       webapp-video-cb475db9c-zfdwr                1/1     Running     0               14m
	app-space       webapp-wear-6886df6554-zjgrf                1/1     Running     0               14m
	ingress-nginx   ingress-nginx-admission-create-667fm        0/1     Completed   0               12m
	ingress-nginx   ingress-nginx-controller-864cdc9fb8-7txkn   1/1     Running     5 (8m33s ago)   10m
	kube-flannel    kube-flannel-ds-wzln6                       1/1     Running     0               17m
	kube-system     coredns-77d6fd4654-62d7r                    1/1     Running     0               17m
	kube-system     coredns-77d6fd4654-dvb6b                    1/1     Running     0               17m
	kube-system     etcd-controlplane                           1/1     Running     0               18m
	kube-system     kube-apiserver-controlplane                 1/1     Running     0               18m
	kube-system     kube-controller-manager-controlplane        1/1     Running     0               18m
	kube-system     kube-proxy-d66jz                            1/1     Running     0               17m
	kube-system     kube-scheduler-controlplane                 1/1     Running     0               18m


Show services in all namespaces
	terminal --> k get svc -A

# result:

NAMESPACE       NAME                                 TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                  AGE
app-space       default-http-backend                 ClusterIP   172.20.122.149   <none>        80/TCP                   23m
app-space       video-service                        ClusterIP   172.20.45.128    <none>        8080/TCP                 23m
app-space       wear-service                         ClusterIP   172.20.167.9     <none>        8080/TCP                 23m
default         kubernetes                           ClusterIP   172.20.0.1       <none>        443/TCP                  27m
ingress-nginx   ingress-nginx-controller             NodePort    172.20.203.252   <none>        80:30080/TCP             17m
ingress-nginx   ingress-nginx-controller-admission   ClusterIP   172.20.87.189    <none>        443/TCP                  21m
kube-system     kube-dns                             ClusterIP   172.20.0.10      <none>        53/UDP,53/TCP,9153/TCP   27m

# We will use 'video-service' and 'wear-service'

Show details for wear-service
	terminal --> k describe svc wear-service -n app-space

# result:

Name:                     wear-service
Namespace:                app-space
Labels:                   <none>
Annotations:              <none>
Selector:                 app=webapp-wear
Type:                     ClusterIP
IP Family Policy:         SingleStack
IP Families:              IPv4
IP:                       172.20.167.9
IPs:                      172.20.167.9
Port:                     <unset>  8080/TCP		# use port 8080
TargetPort:               8080/TCP
Endpoints:                172.17.0.4:8080
Session Affinity:         None
Internal Traffic Policy:  Cluster
Events:                   <none>



Show details for video-service
	terminal --> k describe svc video-service -n app-space

# result:

Name:                     video-service
Namespace:                app-space
Labels:                   <none>
Annotations:              <none>
Selector:                 app=webapp-video
Type:                     ClusterIP
IP Family Policy:         SingleStack
IP Families:              IPv4
IP:                       172.20.45.128
IPs:                      172.20.45.128
Port:                     <unset>  8080/TCP		# use port 8080
TargetPort:               8080/TCP
Endpoints:                172.17.0.5:8080
Session Affinity:         None
Internal Traffic Policy:  Cluster
Events:                   <none>



Show ingress create help command
	terminal --> k create ingress -h

Create Ingress definition file
	terminal --> kubectl create ingress ingress-wear-watch -n app-space --rule="/wear=wear-service:8080" --rule="/watch=video-service:8080" 

	# kubectl					- common kubernetes command
	# create					- create object
	# ingress					- object type
	# ingress-nginx					- object name
	# -n app-space					- namespace of the object
	# --rule="/wear=wear-service:8080"		- specify the path (/wear),service (pay-service) and the port (:8080)
	# --rule="/watch=video-service:8080"		- specify the path (/watch),service (video-service) and the port (:8080)

	# result: ingress.networking.k8s.io/ingress-wear-watch created


Verify the creation
	terminal --> k get ingress -n app-space

# result:

NAME                 CLASS    HOSTS   ADDRESS   PORTS   AGE
ingress-wear-watch   <none>   *                 80      34s



Add annotation in the Ingress
	terminal --> k edit ingress ingress-wear-watch -n app-space

--------------------------------------------------------
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  creationTimestamp: "2025-01-30T20:06:16Z"
  generation: 1
  name: ingress-wear-watch
  namespace: ingress-nginx
  resourceVersion: "3338"
  uid: 57e77ae0-e2e5-4876-8638-52cdf9f0ce64
  annotations:            				# added
    nginx.ingress.kubernetes.io/rewrite-target: /	# added
    nginx.ingress.kubernetes.io/ssl-redirect: "false"	# optional
spec:
  rules:
  - http:
      paths:
      - backend:
          service:
            name: wear-service
            port:
              number: 8080
        path: /wear
        pathType: Exact
      - backend:
          service:
            name: video-service
            port:
              number: 8080
        path: /watch
        pathType: Exact
status:
  loadBalancer:
    ingress:
    - ip: 172.20.203.252
--------------------------------------------------------
save changes - escape, :wq!, enter

# result: ingress.networking.k8s.io/ingress-wear-watch edited


- click 'Check' button




8. Access the application using the Ingress tab on top of your terminal.
------------------------------------------------------------------------
Make sure you can access the right applications at /wear and /watch paths.

Open https://30080-port-o57osybckmfg3ja2.labs.kodekloud.com/wear - working page
Open https://30080-port-o57osybckmfg3ja2.labs.kodekloud.com/watch - working page

- click 'Ok' button



===============================
Section 7 118. Network Policies
===============================

Traffic
=======

We have 3 component architecture
	- Web server (front-end - FE) 	- port 80
	- API server (back-end - BE)	- port 5000
	- DB 				- port 3306


User ---->  Web Server ---->  API Server   ---->     DB
User <----  [port 80]  <----  [port 5000]  <---- [port 3306]

2 Types of traffic
	- Ingress			- incoming traffic from the client
	- Egress			- outgoing traffic from the component


	- Ingress			
		- from users to FE (FE view)		port 80 	(Ingress for the web server)
		- from FE to BE (BE view)		port 5000	(Ingress for the API server)
		- from BE to BE (DB view)		port 3306	(Ingress for DB)

	- Egress
		- from FE to BE (FE view)		port 5000	(Egress for the web server)
		- from BE to DB (BE view)		port 3306	(Egress for the API server)
		- from DB to BE (DB view)		port 3306	(Egress for the DB)



Network Security
================

All nodes in a cluster are in one virutal network that is in "All Allow" mode to secure communication between all pods in all nodes.

So we want to prevent FE to communicate with the DB. We can set network policy to allow communication with DB only to BE. Network policy is another object in the Kubernetes namespace (like pods, replicasets or services). We link network policy to one or more pods. We define rules in the network policy - in this case we will set "Allow Ingress Traffic From BE Pod on Port 3306". Ones set, the policy block all other traffic except that from the BE Pod.

We link network policy to a pod with labels and selectors.

Example for network policy definition file

policy-definition.yaml
----------------------------------------------
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: db-policy
spec:
  podSelector:
    matchLabels:
      role: db
  policyTypes:		# only ingress traffic is isolated (affected), all egress traffic is unaffected
  - Ingress		# if we want to modify egress traffic we need to add it in 'policyTypes' list and set rules
  ingress:
  - from:
    - podSelector:
        matchLabels:
	  name: api-pod  
    ports:
    - protocol: TCP
      port: 3306  
----------------------------------------------

Create a network policy
	terminal --> k create -f policy-definition.yaml


Note :
------
- Solutions that Support Network Policies
	- Kube-router
	- Calico
	- Romana
	- Weave-net

- Solutions that DO NOT Support Network Policies
	- Flannel
	# we can still create network policies, but they will not take effect



==========================================
Section 7 119. Developing Network Policies
==========================================


We have 3 pod architecture in production (prod) environment
	- Web server (front-end - FE) 	- port 80
	- API server (back-end - BE)	- port 5000
	- DB 				- port 3306

User ---->  Web Server ---->  API Server   ---->     DB
User <----  [port 80]  <----  [port 5000]  <---- [port 3306]


We need to set incoming traffic to DB pod to be modified. Only calls from API Server Pod (BE) should be allowed.

Create a network policy with definition file with Ingress (incoming traffic rules)
----------------------------------------------------------------------------------

db-network-policy.yaml
----------------------------------------------
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: db-policy
spec:
  podSelector:
    matchLabels:
      role: db		# select the pods with this label

  policyTypes:		# only ingress traffic is isolated (affected)
  - Ingress		# if we want to modify egress traffic we need to add it in 'policyTypes' list and set rules
  ingress:
  - from:
    - podSelector:		# select other pod 
        matchLabels:
	  name: api-pod 	# API server (BE)
    ports:
    - protocol: TCP
      port: 3306  		
----------------------------------------------

- We plan the rules from the receiving pod's prospective (from DB View)
- When we allow Ingress traffic from other pod, the response traffic is allowed by default.
- The Egress traffic from DB to BE (API) is restricted (not available).


How to manage pod with the same name in different namespaces? We have few more pods.
	- API pod for Dev environment
	- API pod for test environment

To restrict pods with the same name from different namespaces to send requests to our DB we have to add another section named 'namespaceSelector'.

db-network-policy.yaml
----------------------------------------------
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: db-policy
spec:
  podSelector:
    matchLabels:
      role: db		# select the pods witth this label

  policyTypes:		# only ingress traffic is isolated (affected)
  - Ingress		# if we want to modify egress traffic we need to add it in 'policyTypes' list and set rules
  ingress:
  - from:
    - podSelector:		# select other pod 
        matchLabels:
	  name: api-pod 	# API server (BE)
      namespaceSelector:	# set namespace selector to restrict pods from different namespaces
	matchLabel:
	  name: prod
    ports:
    - protocol: TCP
      port: 3306  		
----------------------------------------------


- If 'podSelector' section is not defined and only namespace section is defind, then all pods in the specified namespace will use this network policy. Pods outside spcified (prod) namespace will not be able to communicate with the DB pod.


We have Backup Server (with IP 192.168.5.10) that we want to allow to connect with the DB pod in production namepsace. We can set 'ipBlock' configuration section in the network policy.


db-network-policy.yaml Ingress
----------------------------------------------
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: db-policy
spec:
  podSelector:
    matchLabels:
      role: db		# select the pods witth this label

  policyTypes:		# only ingress traffic is isolated (affected)
  - Ingress		# if we want to modify egress traffic we need to add it in 'policyTypes' list and set rules
  ingress:
  - from:
    - podSelector:		# select pods
        matchLabels:
	  name: api-pod 	# API server (BE)

      namespaceSelector:	# select namespace
	matchLabel:
	  name: prod

    - ipBlock:			# allow IPs to communicate
	cidr: 192.168.5.10/32		# allow traffic from this IP
	
    ports:
    - protocol: TCP
      port: 3306  		
----------------------------------------------

- Every item in the '-from' section is separated rule. They are executed with AND OR logic. 
- Rule selector are executed with AND logic. That means that all criteria must be met - name of the pod must be 'api-pod' and the namespace must match.
----------------------------------------
  - from:
    - podSelector:				- Rule 1 - selector for pods label, including namespace
        matchLabels:
	  name: api-pod
      namespaceSelector:			- additional criteria for rule 1 
	matchLabel:
	  name: prod
    - ipBlock:		  			- Rule 2 - allow traffic from specific IP address (rule 2)
	cidr: 192.168.5.10/32
----------------------------------------

We can specify all configurations under one rule (like in the example above) or separate them each in different rule.

if '-' is added infront 'namespaceSelector', this criteria is become different rule. Small changes like this can have big impact. Below example is set all prods with name 'api-pod' can requests, all pods from namespace 'prod' can traffic.
----------------------------------------
  - from:
    - podSelector:				- Rule 1 - selector for pods label, including namespace
        matchLabels:
	  name: api-pod
    - namespaceSelector:			- Rule 2 - selector for namespace
	matchLabel:
	  name: prod
    - ipBlock:		  			- Rule 3 - allow traffic from specific IP address
	cidr: 192.168.5.10/32
----------------------------------------



Create a network policy with definition file with Egress (outgoing traffic rules)
---------------------------------------------------------------------------------

We have data pushing to the Backup Server (with IP 192.168.5.10, port 80). We have to se egress traffic.

db-network-policy.yaml egress
----------------------------------------------
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: db-policy
spec:
  podSelector:
    matchLabels:
      role: db		# select the pods witth this label

  policyTypes:		# both ingress and egress traffic are affected
  - Ingress		
  - Egress
  ingress:			# incoming traffic
  - from:
    - podSelector:		# select pods
        matchLabels:
	  name: api-pod 	# API server (BE)

    ports:
    - protocol: TCP
      port: 3306  

  egress:					# outgoing traffic
  - to:
    - ipBlock:
	  cidr: 192.168.5.10/32			# IP of the target - backup server
	
    ports:
    - protocol: TCP				
      port: 80  				# what port data will be sent to
----------------------------------------------



===============================================
Section 7 121. Practice Test - Network Policies
===============================================

1. How many network policies do you see in the environment?
-----------------------------------------------------------
We have deployed few web applications, services and network policies. Inspect the environment.

List pods
	terminal --> k get pods

	# result:
	NAME       READY   STATUS    RESTARTS   AGE
	external   1/1     Running   0          80s
	internal   1/1     Running   0          80s
	mysql      1/1     Running   0          80s
	payroll    1/1     Running   0          80s


List services
	terminal --> k get svc

	# result:
	NAME               TYPE        CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
	db-service         ClusterIP   10.100.30.69    <none>        3306/TCP         2m2s
	external-service   NodePort    10.104.66.126   <none>        8080:30080/TCP   2m3s
	internal-service   NodePort    10.99.127.155   <none>        8080:30082/TCP   2m3s
	kubernetes         ClusterIP   10.96.0.1       <none>        443/TCP          44m
	payroll-service    NodePort    10.110.45.31    <none>        8080:30083/TCP   2m2s

Look over the ports that services are set on.


List network policies
	terminal --> k get networkpolicies		# netpol - short syntax

	# result:
	NAME             POD-SELECTOR   AGE
	payroll-policy   name=payroll   3m35s

- choose '1' as answer



2. What is the name of the Network Policy?
------------------------------------------

List network policies
	terminal --> k get networkpolicies		# netpol - short syntax

	# result:
	NAME             POD-SELECTOR   AGE
	payroll-policy   name=payroll   3m35s

- choose 'payroll-policy' as answer



3. Which pod is the Network Policy applied on?
----------------------------------------------

List network policies
	terminal --> k get networkpolicies		# netpol - short syntax

	# result:
	NAME             POD-SELECTOR   AGE
	payroll-policy   name=payroll   3m35s

Show details about the network policy
	terminal --> k describe netpol payroll-policy

payroll-policy
----------------------------------------------
Name:         payroll-policy
Namespace:    default
Created on:   2025-01-22 19:33:21 +0000 UTC
Labels:       <none>
Annotations:  <none>
Spec:
  PodSelector:     name=payroll			# this is the pod of the applied policy
  Allowing ingress traffic:
    To Port: 8080/TCP
    From:
      PodSelector: name=internal
  Not affecting egress traffic
  Policy Types: Ingress
----------------------------------------------

- choose 'payroll' as answer



4. What type of traffic is this Network Policy configured to handle?
--------------------------------------------------------------------

List network policies
	terminal --> k get networkpolicies		# netpol - short syntax

	# result:
	NAME             POD-SELECTOR   AGE
	payroll-policy   name=payroll   3m35s


Show details about the network policy
	terminal --> k describe netpol payroll-policy

payroll-policy
----------------------------------------------
Name:         payroll-policy
Namespace:    default
Created on:   2025-01-22 19:33:21 +0000 UTC
Labels:       <none>
Annotations:  <none>
Spec:
  PodSelector:     name=payroll	
  Allowing ingress traffic:			# ingress is specified
    To Port: 8080/TCP
    From:
      PodSelector: name=internal
  Not affecting egress traffic
  Policy Types: Ingress
----------------------------------------------

- choose 'ingress' as answer



5. What is the impact of the rule configured on this Network Policy?
--------------------------------------------------------------------

List network policies
	terminal --> k get networkpolicies		# netpol - short syntax

	# result:
	NAME             POD-SELECTOR   AGE
	payroll-policy   name=payroll   3m35s


Show details about the network policy
	terminal --> k describe netpol payroll-policy

payroll-policy
----------------------------------------------
Name:         payroll-policy
Namespace:    default
Created on:   2025-01-22 19:33:21 +0000 UTC
Labels:       <none>
Annotations:  <none>
Spec:
  PodSelector:     name=payroll	
  Allowing ingress traffic:
    To Port: 8080/TCP
    From:
      PodSelector: name=internal		# from selector name
  Not affecting egress traffic
  Policy Types: Ingress
----------------------------------------------

- choose 'Traffic from Internal to Payroll is allowed' as answer




6. What is the impact of the rule configured on this Network Policy?
--------------------------------------------------------------------

List network policies
	terminal --> k get networkpolicies		# netpol - short syntax

	# result:
	NAME             POD-SELECTOR   AGE
	payroll-policy   name=payroll   3m35s


Show details about the network policy
	terminal --> k describe netpol payroll-policy

payroll-policy
----------------------------------------------
Name:         payroll-policy
Namespace:    default
Created on:   2025-01-22 19:33:21 +0000 UTC
Labels:       <none>
Annotations:  <none>
Spec:
  PodSelector:     name=payroll	
  Allowing ingress traffic:
    To Port: 8080/TCP
    From:
      PodSelector: name=internal
  Not affecting egress traffic
  Policy Types: Ingress
----------------------------------------------

- choose 'Internal POD can access port 8080 on Payroll POD' as answer




7. Access the UI of these applications using the link given above the terminal.
-------------------------------------------------------------------------------

Open 'External Portal' and 'Internal Portal' tabs on top right side of the console.

On 'External Portal' we have red background
On 'Internal Portal' we have green background 


- click 'Ok' button



8. Perform a connectivity test using the User Interface in these Applications to access the payroll-service at port 8080.
-------------------------------------------------------------------------------------------------------------------------

On 'External Portal' and 'Internal Portal' tabs set HOST as 'payroll-service' and PORT as '8080'
 - click 'TEST' button

On 'External Portal' tab should receive 'timed out'
On 'Internal Portal' tab should receive 'Success!'

- choose 'Only Internal application can access payroll service' as answer



9. Perform a connectivity test using the User Interface of the Internal Application to access the external-service at port 8080.
--------------------------------------------------------------------------------------------------------------------------------

On 'Internal Portal' tabs set HOST as 'external-service' and PORT as '8080'
 - click 'TEST' button

We should receive 'Success!'

- choose 'Successful' as answer




10. Create a network policy to allow traffic from the Internal application only to the payroll-service and db-service.
----------------------------------------------------------------------------------------------------------------------
Use the spec given below. You might want to enable ingress traffic to the pod to test your rules in the UI.
Also, ensure that you allow egress traffic to DNS ports TCP and UDP (port 53) to enable DNS resolution from the internal pod.

Policy Name: internal-policy
Policy Type: Egress
Egress Allow: payroll
Payroll Port: 8080
Egress Allow: mysql
MySQL Port: 3306

We can find syntax on Kubernetes Documentation
	- https://kubernetes.io/docs/concepts/services-networking/network-policies/#networkpolicy-resource


Create the network policy file
	terminal --> vi internal-policy.yaml

internal-policy.yaml
--------------------------------------------------------
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: internal-policy
  namespace: default
spec:
  podSelector:
    matchLabels:
      name: internal
  policyTypes:
  - Egress			# allow traffic from this pod out
  egress:
  - to:
    - podSelector:		# Rule 1
        matchLabels:	
          name: payroll		# to pods with name
    ports:
    - protocol: TCP
      port: 8080
  - to:				# Rule 2
    - podSelector:
        matchLabels:
          name: mysql		# to pods with name
    ports:
    - protocol: TCP
      port: 3306
--------------------------------------------------------
save changes - escape, :wq!, enter

Verify creation of the policy
	terminal --> cat internal-policy.yaml

Create the network policy
	terminal --> k create -f internal-policy.yaml

	# result: networkpolicy.networking.k8s.io/internal-policy created

Verify network policy creation
	terminal --> k describe netpol internal-policy

internal-policy
--------------------------------------------------------
Name:         internal-policy
Namespace:    default
Created on:   2025-01-22 20:11:12 +0000 UTC
Labels:       <none>
Annotations:  <none>
Spec:
  PodSelector:     name=internal
  Not affecting ingress traffic
  Allowing egress traffic:
    To Port: 8080/TCP
    To:
      PodSelector: name=payroll
    ----------
    To Port: 3306/TCP
    To:
      PodSelector: name=mysql
  Policy Types: Egress
--------------------------------------------------------

- click 'Check' button

















